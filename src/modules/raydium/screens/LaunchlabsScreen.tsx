import React, {useState, useCallback, useRef, useEffect} from 'react';
import {
  View,
  Text,
  StyleSheet,
  TouchableOpacity,
  ActivityIndicator,
  ScrollView,
  Alert,
} from 'react-native';
import {SafeAreaView} from 'react-native-safe-area-context';
import {useNavigation} from '@react-navigation/native';
import {Connection, PublicKey} from '@solana/web3.js';
import {NATIVE_MINT} from '@solana/spl-token';
import * as FileSystem from 'expo-file-system';
import {manipulateAsync, SaveFormat} from 'expo-image-manipulator';

import {useAuth} from '../../wallet-providers/hooks/useAuth';
import {useWallet} from '../../wallet-providers/hooks/useWallet';
import {useAppSelector} from '@/shared/hooks/useReduxHooks';
import COLORS from '@/assets/colors';
import TYPOGRAPHY from '@/assets/typography';
import LaunchlabsLaunchSection, {
  TokenData,
} from '../components/LaunchlabsLaunchSection';
import {AdvancedOptionsSection} from '../components/AdvancedOptionsSection';
import {AppHeader} from '@/core/shared-ui';
import {RaydiumService, LaunchpadConfigData, LaunchpadTokenData} from '../services/raydiumService';
import {CLUSTER, HELIUS_STAKED_URL} from '@env';
import {ENDPOINTS} from '@/shared/config/constants';

export default function LaunchlabsScreen() {
  const {solanaWallet} = useAuth();
  const {
    sendTransaction,
    publicKey: walletPublicKey,
    connected,
    address: walletAddress,
  } = useWallet();
  const myWallet = useAppSelector(state => state.auth.address);
  const navigation = useNavigation();

  const [showAdvancedOptions, setShowAdvancedOptions] = useState(false);
  const [tokenData, setTokenData] = useState<TokenData | null>(null);
  const [loading, setLoading] = useState(false);
  const [status, setStatus] = useState<string | null>(null);

  const mountedRef = useRef(true);

  // Clean up on unmount
  useEffect(() => {
    return () => {
      mountedRef.current = false;
    };
  }, []);

  // Function to check if component is still mounted
  const isComponentMounted = useCallback(() => {
    return mountedRef.current;
  }, []);

  // Make sure we use the exact same wallet address in all places
  // Use the wallet's address directly when available
  const userPublicKey =
    walletPublicKey?.toString() || walletAddress || myWallet || null;

  // Log wallet info for debugging
  useEffect(() => {
    if (userPublicKey) {
      console.log('[LaunchlabsScreen] Using wallet address:', userPublicKey);
      console.log(
        '[LaunchlabsScreen] walletPublicKey:',
        walletPublicKey?.toString(),
      );
      console.log('[LaunchlabsScreen] walletAddress:', walletAddress);
      console.log('[LaunchlabsScreen] myWallet:', myWallet);
    }
  }, [userPublicKey, walletPublicKey, walletAddress, myWallet]);

  const handleBack = useCallback(() => {
    if (showAdvancedOptions) {
      // Go back to the initial screen
      setShowAdvancedOptions(false);
      setTokenData(null);
    } else {
      navigation.goBack();
    }
  }, [navigation, showAdvancedOptions]);

  const handleGoToLab = useCallback((data: TokenData) => {
    setTokenData(data);
    setShowAdvancedOptions(true);
  }, []);

  // Handle JustSendIt mode - create token with standard settings
  const handleJustSendIt = useCallback(
    async (data: TokenData) => {
      if (!userPublicKey) {
        Alert.alert('Error', 'Please connect your wallet first');
        return;
      }

      // Check if wallet is connected
      if (!connected) {
        Alert.alert('Error', 'Please connect your wallet to continue');
        return;
      }

      setTokenData(data);
      setLoading(true);
      setStatus('Creating token with JustSendIt...');

      try {
        // Create image data from URI if available
        let imageData = data.imageUri || undefined;
        console.log('[LaunchlabsScreen] Using image URI:', imageData);

        // Create token data for the API
        const launchpadTokenData: LaunchpadTokenData = {
          name: data.name,
          symbol: data.symbol,
          description: data.description,
          decimals: 9, // Default to 9 decimals for Solana tokens
          uri: undefined, // Will be generated by the server
          twitter: data.twitter,
          telegram: data.telegram,
          website: data.website,
          imageData: imageData as string | undefined, // Explicitly cast to string | undefined
        };

        // Create default configuration for JustSendIt mode (standard settings)
        // JustSendIt mode uses these standard values per Raydium docs:
        // - Token Supply: 1 billion tokens (1,000,000,000)
        // - SOL Raised: 85 SOL for AMM threshold
        // - Bonding Curve: 51% of tokens on the bonding curve (Raydium min)
        // - Pool Migration: 49% of tokens (100% - bondingCurve%)
        // - No vesting (0%)
        // - Always use power curve type (default)
        // - Initial buy: Will execute an initial token purchase
        // - createOnly: false (will create token AND buy initial tokens)

        // Create a PublicKey from the string - make sure it's valid
        if (!PublicKey.isOnCurve(new PublicKey(userPublicKey))) {
          throw new Error('Invalid wallet public key');
        }

        const userWalletPublicKey = new PublicKey(userPublicKey);

        // Log the exact public key we're using for debugging
        console.log(
          `[LaunchlabsScreen] Using public key for transaction: ${userWalletPublicKey.toString()}`,
        );

        // Create a connection
        const rpcUrl =
          HELIUS_STAKED_URL ||
          ENDPOINTS.helius ||
          `https://api.${CLUSTER}.solana.com`;
        const connection = new Connection(rpcUrl, 'confirmed');

        const configData: LaunchpadConfigData = {
          mode: 'justSendIt',
          initialBuyAmount: data.initialBuyAmount,
        };

        // Call the RaydiumService to create the token with standard settings
        const result = await RaydiumService.createAndLaunchToken(
          launchpadTokenData,
          userWalletPublicKey,
          sendTransaction,
          {
            statusCallback: setStatus,
            isComponentMounted,
          },
          configData
        );

        if (result.success) {
          Alert.alert(
            'Success',
            `Token created with JustSendIt!\nToken address: ${result.mintAddress}\nPool ID: ${result.poolId}`,
            [
              {
                text: 'OK',
                onPress: () => {
                  // Reset the form
                  setTokenData(null);
                },
              },
            ],
          );
        } else {
          Alert.alert(
            'Error',
            result.error?.toString() || 'Failed to create token',
          );
        }
      } catch (error: any) {
        console.error('JustSendIt error:', error);
        Alert.alert('Error', error.message || 'An unexpected error occurred');
      } finally {
        setLoading(false);
        setStatus(null);
      }
    },
    [userPublicKey, isComponentMounted, connected, sendTransaction],
  );

  // Handle token creation with custom parameters (LaunchLab mode)
  const handleCreateToken = useCallback(
    async (configData: LaunchpadConfigData) => {
      if (!tokenData || !userPublicKey) {
        Alert.alert('Error', 'Missing required data to create token');
        return;
      }

      // Check if wallet is connected
      if (!connected) {
        Alert.alert('Error', 'Please connect your wallet to continue');
        return;
      }

      setLoading(true);
      setStatus('Creating token with LaunchLab...');

      try {
        // Use the image URI directly
        let imageData = tokenData.imageUri || undefined;
        console.log('[LaunchlabsScreen] Using image URI:', imageData);

        // Create token data object for the API
        const launchpadTokenData: LaunchpadTokenData = {
          name: tokenData.name,
          symbol: tokenData.symbol,
          description: tokenData.description,
          decimals: 9, // Default to 9 decimals for Solana tokens
          uri: undefined, // Will be generated by the server if not provided
          twitter: tokenData.twitter,
          telegram: tokenData.telegram,
          website: tokenData.website,
          imageData: imageData as string | undefined, // Explicitly cast to string | undefined
        };

        // Update the createOnly parameter based on tokenData.initialBuyEnabled
        const updatedConfigData = {
          ...configData,
          createOnly: !tokenData.initialBuyEnabled, // Override with value from tokenData
          initialBuyAmount: tokenData.initialBuyAmount, // Include the initial buy amount
        };

        // Create a PublicKey from the string - make sure it's valid
        if (!PublicKey.isOnCurve(new PublicKey(userPublicKey))) {
          throw new Error('Invalid wallet public key');
        }

        const userWalletPublicKey = new PublicKey(userPublicKey);

        // Log the exact public key we're using for debugging
        console.log(
          `[LaunchlabsScreen] Using public key for transaction: ${userWalletPublicKey.toString()}`,
        );

        // Create a connection
        const rpcUrl =
          HELIUS_STAKED_URL ||
          ENDPOINTS.helius ||
          `https://api.${CLUSTER}.solana.com`;
        const connection = new Connection(rpcUrl, 'confirmed');

        // Call the RaydiumService to create the token with custom settings
        const result = await RaydiumService.createAndLaunchToken(
          launchpadTokenData,
          userWalletPublicKey,
          sendTransaction,
          {
            statusCallback: setStatus,
            isComponentMounted,
          },
          updatedConfigData
        );

        if (result.success) {
          Alert.alert(
            'Success',
            `Token created with LaunchLab!\nToken address: ${result.mintAddress}\nPool ID: ${result.poolId}`,
            [
              {
                text: 'OK',
                onPress: () => {
                  // Reset the form and go back to the first screen
                  setShowAdvancedOptions(false);
                  setTokenData(null);
                },
              },
            ],
          );
        } else {
          Alert.alert(
            'Error',
            result.error?.toString() || 'Failed to create token',
          );
        }
      } catch (error: any) {
        console.error('LaunchLab error:', error);
        Alert.alert('Error', error.message || 'An unexpected error occurred');
      } finally {
        setLoading(false);
        setStatus(null);
      }
    },
    [tokenData, userPublicKey, isComponentMounted, connected, sendTransaction],
  );

  if (!userPublicKey) {
    return (
      <SafeAreaView style={styles.safeArea}>
        <AppHeader
          title="LaunchLab"
          showBackButton={true}
          onBackPress={handleBack}
          showDefaultRightIcons={true}
        />
        <View style={styles.centeredMessageContainer}>
          <Text style={styles.warnText}>Please connect your wallet first!</Text>
        </View>
      </SafeAreaView>
    );
  }

  return (
    <SafeAreaView style={styles.safeArea}>
      <AppHeader
        title="LaunchLab"
        showBackButton={true}
        onBackPress={handleBack}
        showDefaultRightIcons={true}
      />

      <ScrollView
        style={styles.scrollContainer}
        contentContainerStyle={styles.scrollContent}>
        <Text style={styles.sectionTitle}>
          {showAdvancedOptions
            ? 'Configure token options'
            : 'Launch a token via Raydium'}
        </Text>

        {loading && status && (
          <View style={styles.statusContainer}>
            <ActivityIndicator
              size="small"
              color={COLORS.brandBlue}
              style={styles.loader}
            />
            <Text style={styles.statusText}>{status}</Text>
          </View>
        )}

        {!showAdvancedOptions ? (
          <LaunchlabsLaunchSection
            containerStyle={styles.cardContainer}
            inputStyle={styles.input}
            buttonStyle={styles.button}
            launchButtonLabel="Launch on Raydium"
            onGoToLab={handleGoToLab}
            onJustSendIt={handleJustSendIt}
          />
        ) : (
          <AdvancedOptionsSection
            containerStyle={styles.cardContainer}
            onCreateToken={handleCreateToken}
            onBack={handleBack}
            isLoading={loading}
            tokenName={tokenData?.name}
            tokenSymbol={tokenData?.symbol}
          />
        )}
      </ScrollView>
    </SafeAreaView>
  );
}

const styles = StyleSheet.create({
  safeArea: {
    flex: 1,
    backgroundColor: COLORS.background,
  },
  scrollContainer: {
    flex: 1,
  },
  scrollContent: {
    padding: 16,
    paddingBottom: 40,
  },
  centeredMessageContainer: {
    flex: 1,
    justifyContent: 'center',
    alignItems: 'center',
    padding: 16,
  },
  warnText: {
    fontSize: TYPOGRAPHY.size.lg,
    color: COLORS.white,
    textAlign: 'center',
    fontFamily: TYPOGRAPHY.fontFamily,
  },
  sectionTitle: {
    fontSize: TYPOGRAPHY.size.lg,
    fontWeight: TYPOGRAPHY.fontWeightToString(TYPOGRAPHY.semiBold),
    color: COLORS.white,
    marginBottom: 16,
    fontFamily: TYPOGRAPHY.fontFamily,
    alignSelf: 'center',
  },
  cardContainer: {
    backgroundColor: COLORS.background,
    padding: 10,
    borderRadius: 12,
    marginBottom: 20,
  },
  input: {
    backgroundColor: 'transparent',
    color: COLORS.white,
    borderRadius: 8,
    paddingHorizontal: 16,
    paddingVertical: 12,
    fontSize: TYPOGRAPHY.size.md,
    borderWidth: 1.5,
    borderColor: COLORS.borderDarkColor,
    marginBottom: 12,
    fontFamily: TYPOGRAPHY.fontFamily,
  },
  button: {
    backgroundColor: COLORS.brandBlue,
    paddingVertical: 12,
    borderRadius: 10,
    alignItems: 'center',
    width: '100%',
  },
  statusContainer: {
    flexDirection: 'row',
    alignItems: 'center',
    backgroundColor: COLORS.lighterBackground,
    padding: 12,
    borderRadius: 8,
    marginBottom: 16,
  },
  loader: {
    marginRight: 10,
  },
  statusText: {
    color: COLORS.white,
    fontSize: TYPOGRAPHY.size.sm,
    fontFamily: TYPOGRAPHY.fontFamily,
  },
});
